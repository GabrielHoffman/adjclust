---
title: "Adjacency-constrained hierarchical clustering of Single Nucleotide Polymorphisms"
author: "Pierre Neuvial, Shubham Chaturvedi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Adjacency-constrained hierarchical clustering of Single Nucleotide Polymorphisms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In this short vignette we demonstrate the use of `snpclust` function in the `adjclust` package. `snpclust` performs adjacency-constrained hierarchical clustering of single nucleotide polymorphisms. `snpclust` is specialized version of `adjClustBand_heap` function designed specially to perform clustering of single nucleotide polymorphisms. This function implements the algorithm same as `adjClustBand_heap` described in the third chapter of [2]. It is an extension of the algorithm described in [3].  


```{r, message = FALSE}
library("adjclust")
```

## Loading and displaying genotype data

The begining of this vignette closely follows the "LD vignette" of the SnpStats package [1]. First, we load genotype data.

```{r, results="hide", message=FALSE}
library("matrixStats")
library("snpStats")
data("ld.example", package="snpStats")
```

```{r, echo=FALSE}
p <- ncol(ceph.1mb)
nSamples <- nrow(ceph.1mb)
```

We focus on the `ceph.1mb` data. These data are drawn from the International HapMap Project and concern `r p` SNPs over a 1Mb region of chromosome 22 in sample of `r nSamples` Europeans.

```{r}
ceph.1mb
```

We can compute and display the LD between these SNPs.

```{r}
ld.ceph <- ld(ceph.1mb, stats="R.squared", depth=p-1)
image(ld.ceph, lwd=0)
```

## Adjacency-constrained Hierarchical Agglomerative Clustering

The above figure suggests that the LD signal is concentrated close to the diagonal. Therefore, we focus on a diagonal band:

```{r}
h <- 100
ld.ceph <- ld(ceph.1mb, stats="R.squared", depth=h)
image(ld.ceph, lwd=0)
```

## Check data for presence of missing values or NaNs and eliminate them

```{r}
any(is.na(ld.ceph))
# which(is.na(ld.ceph), arr.ind = TRUE)
ceph.1mb[4,286]@.Data[1,1] <- as.raw(3)  ## to avoid NaNs
ld.ceph <- ld(ceph.1mb, stats="R.squared", depth=h)  ## calculate LD values again after NaN correction
ld.ceph <- round(ld.ceph, digits=10)  ## precision above 1e-10 is not required for this example
any(is.na(ld.ceph))
diag(ld.ceph) <- 1
```

## Using snpclust function with different input classes

###Case 1: Input belongs to class Matrix::dgCMatrix generated by snpStats::ld function
```{r}
  class(ld.ceph)
  fit1 <- snpclust(ld.ceph, h)
```

###Case 2: Input belongs to class snpStats::SnpMatrix

```{r}
  class(ceph.1mb)
  fit2 <- snpclust(ceph.1mb, h, "R.squared")  
```

###Case3: Input belongs class base::matrix

```{r}
  ceph.1mb <- as.matrix(ceph.1mb)
  class(ceph.1mb)
  fit3 <- snpclust(ceph.1mb, h, "R.squared")  
```
  
The output is of class "hclust" and can be plotted as a dendrogram.


In particular, the output contains an element named `merge` which describes the successive merges of the clustering, and an element `gains` which gives the improvement in the criterion optimized by the clustering at each successive merge.

```{r}
head(cbind(fit1$merge, fit1$gains))
```

The output can also be plotted as dendogram

For equivalent input in different classes, we get equivalent results.In this example, fit1, fit2 and fit3 are equivalent.

```{r}
all.equal(fit1$merge, fit2$merge)
all.equal(fit1$gains, fit2$gains)

all.equal(fit2$merge, fit3$merge)
all.equal(fit2$gains, fit3$gains)
```

## References

[1] Clayton, D. (2015). snpStats: SnpMatrix and XSnpMatrix classes and methods. R package version 1.20.0

[2] Dehman A. (2015). [Spatial clustering of linkage disequilibrium blocks for genome-wide association studies](https://tel.archives-ouvertes.fr/tel-01288568/). Phd Thesis, UniversitÃ© Paris Saclay.

[3] Dehman, A. Ambroise, C. and Neuvial, P. (2015). Performance of a blockwise approach in variable selection using linkage disequilibrium information. *BMC Bioinformatics* 16:148.

## Session information

```{r}
sessionInfo()
```
